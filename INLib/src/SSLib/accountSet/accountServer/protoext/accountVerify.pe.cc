// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

#include "accountVerify.pe.h"
#include <BCLib/utility/convert.h>
#include <BCLib/utility/logFile.h>

namespace PTExt
{

CAccountVerify::CAccountVerify()
{
}

CAccountVerify::CAccountVerify(const PTBuf::CAccountVerify& ptBuf)
{
    m_ptBuf = ptBuf;
}

CAccountVerify::~CAccountVerify()
{
}

PTBuf::CAccountVerify& CAccountVerify::getBuf()
{
    return m_ptBuf;
}

void CAccountVerify::dumpInfo()
{
    BCLIB_LOG_TRACE(BCLib::ELOGMODULE_DEFAULT, "DumpInfo : accountid = %llu, platformname = %s, channelname = %s, accountname = %s, accountpwd = %s, accountkey = %s, deviceid = %s", m_ptBuf.accountid(), m_ptBuf.platformname().c_str(), m_ptBuf.channelname().c_str(), m_ptBuf.accountname().c_str(), m_ptBuf.accountpwd().c_str(), m_ptBuf.accountkey().c_str(), m_ptBuf.deviceid().c_str());
}

bool CAccountVerify::isValidity(PTBuf::CAccountVerify& ptBuf)
{
    std::string strValue = "";

    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.platformname());
    if (strValue.size() > 64) return false;
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.channelname());
    if (strValue.size() > 64) return false;
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.accountname());
    if (strValue.size() > 64) return false;
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.accountpwd());
    if (strValue.size() > 32) return false;
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.accountkey());
    if (strValue.size() > 64) return false;
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.deviceid());
    if (strValue.size() > 128) return false;

    return true;
}

bool CAccountVerify::makeValidity(PTBuf::CAccountVerify& ptBuf)
{
    std::string strValue = "";

    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.platformname());
    if (strValue.size() > 64) strValue = strValue.substr(0, 64);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_platformname(strValue);
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.channelname());
    if (strValue.size() > 64) strValue = strValue.substr(0, 64);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_channelname(strValue);
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.accountname());
    if (strValue.size() > 64) strValue = strValue.substr(0, 64);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_accountname(strValue);
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.accountpwd());
    if (strValue.size() > 32) strValue = strValue.substr(0, 32);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_accountpwd(strValue);
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.accountkey());
    if (strValue.size() > 64) strValue = strValue.substr(0, 64);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_accountkey(strValue);
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.deviceid());
    if (strValue.size() > 128) strValue = strValue.substr(0, 128);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_deviceid(strValue);

    return true;
}

bool CAccountVerify::canUpdate(PTBuf::CAccountVerify& oldBuf, PTBuf::CAccountVerify& newBuf)
{
    return true;
}

BCLIB_SINGLETON_DEFINE(CAccountVerifyOwner)

CAccountVerifyOwner::CAccountVerifyOwner()
{
}

CAccountVerifyOwner::~CAccountVerifyOwner()
{
}

bool CAccountVerifyOwner::addObject(BCLib::uint64 key, const PTBuf::CAccountVerify& ptBuf)
{
    if (m_hashMap.find(key) != m_hashMap.end()) return false;

    PTExt::CAccountVerify tmpBuf(ptBuf);
    m_hashMap.setValue(key, tmpBuf);
    return true;
}

bool CAccountVerifyOwner::addObject(BCLib::uint64 key, const PTExt::CAccountVerify& ptBuf)
{
    if (m_hashMap.find(key) != m_hashMap.end()) return false;

    m_hashMap.setValue(key, ptBuf);
    return true;
}

PTExt::CAccountVerify* CAccountVerifyOwner::getObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return NULL;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        return &it->second;
    }

    return NULL;
}

bool CAccountVerifyOwner::delObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return false;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        m_hashMap.erase(it);
        return true;
    }

    return true;
}

void CAccountVerifyOwner::dumpInfo(BCLib::uint64 entityID)
{
    if (entityID == 0) return;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        it->second.dumpInfo();
    }
}


CAccountVerifyList::CAccountVerifyList()
{
}

CAccountVerifyList::CAccountVerifyList(const PTBuf::CAccountVerifyList& ptList)
{
    m_List = ptList;
}

CAccountVerifyList::~CAccountVerifyList()
{
}

PTBuf::CAccountVerifyList& CAccountVerifyList::getList()
{
    return m_List;
}

void CAccountVerifyList::dumpInfo()
{
    for(int i = 0; i < m_List.objects_size(); i++)
    {
        CAccountVerify tmpBuf(m_List.objects(i));
        tmpBuf.dumpInfo();
    }
}

bool CAccountVerifyList::addObject(const PTBuf::CAccountVerify& ptBuf)
{
    for(int i = 0; i < m_List.objects_size(); i++)
    {
        if (m_List.objects(i).accountid() == ptBuf.accountid())
        {
            return false;
        }
    }

    PTBuf::CAccountVerify* pBuf = m_List.add_objects();
    if (!pBuf) return false;

    *pBuf = ptBuf;
    return true;
}

const PTBuf::CAccountVerify* CAccountVerifyList::getObject(BCLib::uint64 accountID)
{
    if (accountID == 0) return NULL;

    for(int i = 0; i < m_List.objects_size(); i++)
    {
        if (m_List.objects(i).accountid() == accountID)
        {
            return &m_List.objects(i);
        }
    }

    return NULL;
}

bool CAccountVerifyList::delObject(BCLib::uint64 accountID)
{
    if (accountID == 0) return false;
    if (m_List.objects_size() <= 0) return false;

    int nIndex = 0;
    for(int i = 0; i < m_List.objects_size(); i++)
    {
        if (m_List.objects(i).accountid() == accountID)
        {
            nIndex = i;
            break;
        }
    }

    ::google::protobuf::RepeatedPtrField<PTBuf::CAccountVerify>* repeated = (::google::protobuf::RepeatedPtrField<PTBuf::CAccountVerify>*)&m_List.objects();
    if (repeated)
    {
        repeated->SwapElements(nIndex, repeated->size() - 1);
        repeated->RemoveLast();
    }
    return true;
}

void CAccountVerifyList::makeValidity()
{
    for(int i = 0; i < m_List.objects_size(); i++)
    {
        PTBuf::CAccountVerify* tmpObj = (PTBuf::CAccountVerify*)&m_List.objects(i);
        PTExt::CAccountVerify::makeValidity(*tmpObj);
    }
}

void CAccountVerifyList::makeValidity(PTBuf::CAccountVerifyList& ptList)
{
    for(int i = 0; i < ptList.objects_size(); i++)
    {
        PTBuf::CAccountVerify* tmpObj = (PTBuf::CAccountVerify*)&ptList.objects(i);
        PTExt::CAccountVerify::makeValidity(*tmpObj);
    }
}


BCLIB_SINGLETON_DEFINE(CAccountVerifyListCtrl)

CAccountVerifyListCtrl::CAccountVerifyListCtrl()
{
}

CAccountVerifyListCtrl::~CAccountVerifyListCtrl()
{
}


BCLIB_SINGLETON_DEFINE(CAccountVerifyListOwner)

CAccountVerifyListOwner::CAccountVerifyListOwner()
{
}

CAccountVerifyListOwner::~CAccountVerifyListOwner()
{
}

bool CAccountVerifyListOwner::addObject(BCLib::uint64 entityID, const PTBuf::CAccountVerifyList& ptList)
{
    if (m_hashMap.find(entityID) != m_hashMap.end()) return false;

    PTExt::CAccountVerifyList tmpList(ptList);
    m_hashMap.setValue(entityID, tmpList);
    return true;
}

bool CAccountVerifyListOwner::addObject(BCLib::uint64 entityID, const PTExt::CAccountVerifyList& ptList)
{
    if (m_hashMap.find(entityID) != m_hashMap.end()) return false;

    m_hashMap.setValue(entityID, ptList);
    return true;
}

PTExt::CAccountVerifyList* CAccountVerifyListOwner::getObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return NULL;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        return &it->second;
    }

    return NULL;
}

bool CAccountVerifyListOwner::delObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return false;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        m_hashMap.erase(it);
        return true;
    }

    return true;
}

void CAccountVerifyListOwner::dumpInfo(BCLib::uint64 entityID)
{
    if (entityID == 0) return;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        it->second.dumpInfo();
    }
}


} // namespace PTExt
