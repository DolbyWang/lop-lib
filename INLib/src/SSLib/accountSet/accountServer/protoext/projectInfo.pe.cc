// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

#include "projectInfo.pe.h"
#include <BCLib/utility/convert.h>
#include <BCLib/utility/logFile.h>

namespace PTExt
{

CProjectInfo::CProjectInfo()
{
}

CProjectInfo::CProjectInfo(const PTBuf::CProjectInfo& ptBuf)
{
    m_ptBuf = ptBuf;
}

CProjectInfo::~CProjectInfo()
{
}

PTBuf::CProjectInfo& CProjectInfo::getBuf()
{
    return m_ptBuf;
}

void CProjectInfo::dumpInfo()
{
    BCLIB_LOG_TRACE(BCLib::ELOGMODULE_DEFAULT, "DumpInfo : projectid = %llu, projectname = %s, accountid = %llu, projecttype = %u, projectstate = %u, members = %s", m_ptBuf.projectid(), m_ptBuf.projectname().c_str(), m_ptBuf.accountid(), m_ptBuf.projecttype(), m_ptBuf.projectstate(), m_ptBuf.members().c_str());
}

bool CProjectInfo::isValidity(PTBuf::CProjectInfo& ptBuf)
{
    std::string strValue = "";

    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.projectname());
    if (strValue.size() > 64) return false;
    // ushort
    if (ptBuf.projecttype() > BCLIB_UINT16_MAX) return false;
    // byte
    if (ptBuf.projectstate() > BCLIB_UINT8_MAX) return false;
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.members());
    if (strValue.size() > 4096) return false;

    return true;
}

bool CProjectInfo::makeValidity(PTBuf::CProjectInfo& ptBuf)
{
    std::string strValue = "";

    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.projectname());
    if (strValue.size() > 64) strValue = strValue.substr(0, 64);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_projectname(strValue);
    // ushort
    if (ptBuf.projecttype() > BCLIB_UINT16_MAX) ptBuf.set_projecttype(BCLIB_UINT16_MAX);
    // byte
    if (ptBuf.projectstate() > BCLIB_UINT8_MAX) ptBuf.set_projectstate(BCLIB_UINT8_MAX);
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.members());
    if (strValue.size() > 4096) strValue = strValue.substr(0, 4096);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_members(strValue);

    return true;
}

bool CProjectInfo::canUpdate(PTBuf::CProjectInfo& oldBuf, PTBuf::CProjectInfo& newBuf)
{
    return true;
}

BCLIB_SINGLETON_DEFINE(CProjectInfoOwner)

CProjectInfoOwner::CProjectInfoOwner()
{
}

CProjectInfoOwner::~CProjectInfoOwner()
{
}

bool CProjectInfoOwner::addObject(BCLib::uint64 key, const PTBuf::CProjectInfo& ptBuf)
{
    if (m_hashMap.find(key) != m_hashMap.end()) return false;

    PTExt::CProjectInfo tmpBuf(ptBuf);
    m_hashMap.setValue(key, tmpBuf);
    return true;
}

bool CProjectInfoOwner::addObject(BCLib::uint64 key, const PTExt::CProjectInfo& ptBuf)
{
    if (m_hashMap.find(key) != m_hashMap.end()) return false;

    m_hashMap.setValue(key, ptBuf);
    return true;
}

PTExt::CProjectInfo* CProjectInfoOwner::getObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return NULL;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        return &it->second;
    }

    return NULL;
}

bool CProjectInfoOwner::delObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return false;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        m_hashMap.erase(it);
        return true;
    }

    return true;
}

void CProjectInfoOwner::dumpInfo(BCLib::uint64 entityID)
{
    if (entityID == 0) return;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        it->second.dumpInfo();
    }
}


CProjectInfoList::CProjectInfoList()
{
}

CProjectInfoList::CProjectInfoList(const PTBuf::CProjectInfoList& ptList)
{
    m_List = ptList;
}

CProjectInfoList::~CProjectInfoList()
{
}

void CProjectInfoList::dumpInfo()
{
    for(int i = 0; i < m_List.objects_size(); i++)
    {
        CProjectInfo tmpBuf(m_List.objects(i));
        tmpBuf.dumpInfo();
    }
}

PTBuf::CProjectInfoList& CProjectInfoList::getList()
{
    return m_List;
}


BCLIB_SINGLETON_DEFINE(CProjectInfoListCtrl)

CProjectInfoListCtrl::CProjectInfoListCtrl()
{
}

CProjectInfoListCtrl::~CProjectInfoListCtrl()
{
}


BCLIB_SINGLETON_DEFINE(CProjectInfoListOwner)

CProjectInfoListOwner::CProjectInfoListOwner()
{
}

CProjectInfoListOwner::~CProjectInfoListOwner()
{
}

bool CProjectInfoListOwner::addObject(BCLib::uint64 entityID, const PTBuf::CProjectInfoList& ptList)
{
    if (m_hashMap.find(entityID) != m_hashMap.end()) return false;

    PTExt::CProjectInfoList tmpList(ptList);
    m_hashMap.setValue(entityID, tmpList);
    return true;
}

bool CProjectInfoListOwner::addObject(BCLib::uint64 entityID, const PTExt::CProjectInfoList& ptList)
{
    if (m_hashMap.find(entityID) != m_hashMap.end()) return false;

    m_hashMap.setValue(entityID, ptList);
    return true;
}

PTExt::CProjectInfoList* CProjectInfoListOwner::getObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return NULL;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        return &it->second;
    }

    return NULL;
}

bool CProjectInfoListOwner::delObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return false;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        m_hashMap.erase(it);
        return true;
    }

    return true;
}

void CProjectInfoListOwner::dumpInfo(BCLib::uint64 entityID)
{
    if (entityID == 0) return;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        it->second.dumpInfo();
    }
}


} // namespace PTExt
