// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

#include "accountInfo.pe.h"
#include <BCLib/utility/convert.h>
#include <BCLib/utility/logFile.h>

namespace PTExt
{

CAccountInfo::CAccountInfo()
{
}

CAccountInfo::CAccountInfo(const PTBuf::CAccountInfo& ptBuf)
{
    m_ptBuf = ptBuf;
}

CAccountInfo::~CAccountInfo()
{
}

PTBuf::CAccountInfo& CAccountInfo::getBuf()
{
    return m_ptBuf;
}

void CAccountInfo::dumpInfo()
{
    BCLIB_LOG_TRACE(BCLib::ELOGMODULE_DEFAULT, "DumpInfo : accountid = %llu, grouplist = %s, projectlist = %s", m_ptBuf.accountid(), m_ptBuf.grouplist().c_str(), m_ptBuf.projectlist().c_str());
}

bool CAccountInfo::isValidity(PTBuf::CAccountInfo& ptBuf)
{
    std::string strValue = "";

    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.grouplist());
    if (strValue.size() > 4096) return false;
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.projectlist());
    if (strValue.size() > 4096) return false;

    return true;
}

bool CAccountInfo::makeValidity(PTBuf::CAccountInfo& ptBuf)
{
    std::string strValue = "";

    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.grouplist());
    if (strValue.size() > 4096) strValue = strValue.substr(0, 4096);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_grouplist(strValue);
    // string
    strValue = "";
    BCLib::Utility::CConvert::utf8ToGB2312(strValue, ptBuf.projectlist());
    if (strValue.size() > 4096) strValue = strValue.substr(0, 4096);
    BCLib::Utility::CConvert::gb2312ToUTF8(strValue, strValue);
    ptBuf.set_projectlist(strValue);

    return true;
}

bool CAccountInfo::canUpdate(PTBuf::CAccountInfo& oldBuf, PTBuf::CAccountInfo& newBuf)
{
    return true;
}

BCLIB_SINGLETON_DEFINE(CAccountInfoOwner)

CAccountInfoOwner::CAccountInfoOwner()
{
}

CAccountInfoOwner::~CAccountInfoOwner()
{
}

bool CAccountInfoOwner::addObject(BCLib::uint64 key, const PTBuf::CAccountInfo& ptBuf)
{
    if (m_hashMap.find(key) != m_hashMap.end()) return false;

    PTExt::CAccountInfo tmpBuf(ptBuf);
    m_hashMap.setValue(key, tmpBuf);
    return true;
}

bool CAccountInfoOwner::addObject(BCLib::uint64 key, const PTExt::CAccountInfo& ptBuf)
{
    if (m_hashMap.find(key) != m_hashMap.end()) return false;

    m_hashMap.setValue(key, ptBuf);
    return true;
}

PTExt::CAccountInfo* CAccountInfoOwner::getObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return NULL;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        return &it->second;
    }

    return NULL;
}

bool CAccountInfoOwner::delObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return false;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        m_hashMap.erase(it);
        return true;
    }

    return true;
}

void CAccountInfoOwner::dumpInfo(BCLib::uint64 entityID)
{
    if (entityID == 0) return;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        it->second.dumpInfo();
    }
}


CAccountInfoList::CAccountInfoList()
{
}

CAccountInfoList::CAccountInfoList(const PTBuf::CAccountInfoList& ptList)
{
    m_List = ptList;
}

CAccountInfoList::~CAccountInfoList()
{
}

void CAccountInfoList::dumpInfo()
{
    for(int i = 0; i < m_List.objects_size(); i++)
    {
        CAccountInfo tmpBuf(m_List.objects(i));
        tmpBuf.dumpInfo();
    }
}

PTBuf::CAccountInfoList& CAccountInfoList::getList()
{
    return m_List;
}


BCLIB_SINGLETON_DEFINE(CAccountInfoListCtrl)

CAccountInfoListCtrl::CAccountInfoListCtrl()
{
}

CAccountInfoListCtrl::~CAccountInfoListCtrl()
{
}


BCLIB_SINGLETON_DEFINE(CAccountInfoListOwner)

CAccountInfoListOwner::CAccountInfoListOwner()
{
}

CAccountInfoListOwner::~CAccountInfoListOwner()
{
}

bool CAccountInfoListOwner::addObject(BCLib::uint64 entityID, const PTBuf::CAccountInfoList& ptList)
{
    if (m_hashMap.find(entityID) != m_hashMap.end()) return false;

    PTExt::CAccountInfoList tmpList(ptList);
    m_hashMap.setValue(entityID, tmpList);
    return true;
}

bool CAccountInfoListOwner::addObject(BCLib::uint64 entityID, const PTExt::CAccountInfoList& ptList)
{
    if (m_hashMap.find(entityID) != m_hashMap.end()) return false;

    m_hashMap.setValue(entityID, ptList);
    return true;
}

PTExt::CAccountInfoList* CAccountInfoListOwner::getObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return NULL;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        return &it->second;
    }

    return NULL;
}

bool CAccountInfoListOwner::delObject(BCLib::uint64 entityID)
{
    if (entityID == 0) return false;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        m_hashMap.erase(it);
        return true;
    }

    return true;
}

void CAccountInfoListOwner::dumpInfo(BCLib::uint64 entityID)
{
    if (entityID == 0) return;

    THashMap::iterator it = m_hashMap.find(entityID);
    if (it != m_hashMap.end())
    {
        it->second.dumpInfo();
    }
}


} // namespace PTExt
